# 黑马点评学习进度

---

## 📋 学习记录规范（每次学习必须按照此格式记录）

### 记录模板
```markdown
## YYYY-MM-DD 学习记录（上午/下午/晚上/凌晨）

### ✅ 今天完成
1. **主要任务1**
   - 具体做了什么
   - 理解了什么概念
   - 实现了什么功能

2. **主要任务2**
   - ...

### 📝 关键理解
- 用自己的话阐述核心概念（费曼学习法）
- 必须能完整表达，才算真正学会

### 💡 重要认知
- 学习过程中的顿悟时刻
- 对之前错误理解的纠正

### 🤔 待解决的疑问
- 疑问1（需要同步到"疑问记录.md"）
- 疑问2

### ⏳ 下一步计划
- 明确下次学习要做什么

### 📂 代码位置
- 涉及的文件和具体行数

### 🎯 今天的收获
- 总结今天学到的东西
```

### 记录要求
1. **必须当天记录**，不能拖延
2. **必须用自己的话阐述**，不能复制AI的回答
3. **疑问必须同步**到"疑问记录.md"
4. **代码位置必须明确**，方便复习
5. **下一步计划必须具体**，不能模糊

---

## 2026-02-27 学习记录（晚上）

### ✅ 今天完成

1. **完善前端搜索入口（index.html）**
   - 加入搜索栏，支持普通搜索和AI语义搜索切换（toggle开关）
   - 去掉"AI已开启"badge（点击时会跳动，体验差）
   - AI搜索结果从5条改为30条
   - 分类图标从■替换为彩色emoji（美食🍜、KTV🎤等）

2. **关注动态页面重构（follow.html）**
   - 从单列改为两列瀑布流（column-count: 2），与blog.html保持一致
   - 加入搜索栏：支持按笔记标题 / 博主搜索

3. **探店笔记搜索功能（blog.html）**
   - 加入搜索栏，两个tab：笔记标题 / 博主
   - 多关键词OR搜索，按符合程度从高到低排序（CASE WHEN relevance score）
   - 后端新增两个接口：`GET /blog/search/title` 和 `GET /blog/search/user`

4. **博客关联店铺卡片（blog-detail.html）**
   - 博客详情页展示关联店铺卡片，点击跳转到店铺详情
   - 利用已有的 `blog.shopId` 字段，无需改数据库

5. **优惠券核销码系统**
   - 用 orderId 直接作为核销码（RedisIdWorker全局唯一，无需新字段）
   - 新建商家核销页面 `verify.html`：输入核销码 → POST验证 → 显示结果
   - 个人中心 status=2 的订单显示红色虚线核销码 + 复制按钮

6. **普通代金券领取功能**
   - 新增 `claimVoucher` 接口：type=0普通券，一人一张，Redisson防并发，直接status=2
   - 修复type判断bug：原来错误地检查type=2，实际DB中普通券是type=0，秒杀券是type=1

7. **完整支付流程（模拟支付）**
   - 秒杀券抢购后 status=1（待支付），不再直接status=2
   - 新增 `payOrder` 接口：status=1 → status=2，返回orderId作为核销码
   - 新增 `cancelOrder` 接口：status=1 → status=4（已取消）
   - 个人中心：status=1显示"去支付"+"取消订单"按钮，支付成功后直接展示核销码
   - 普通券仍直接status=2（免费领取，无需支付步骤）

8. **补充测试数据**
   - 给店铺2-14各添加一张普通代金券（id 100-112）
   - 给店铺2、5、10各添加一张秒杀券（id 200-202）+ tb_seckill_voucher库存记录

### 📝 关键理解

- **订单状态机**：1=待支付 → 2=已支付（有核销码）→ 3=已核销；1也可以 → 4=已取消
- **核销码设计**：不需要单独字段，orderId本身就是全局唯一的18位数字，直接当核销码用
- **普通券 vs 秒杀券**：普通券免费领取直接可用，秒杀券需要支付确认才能拿到核销码，跟美团/抖音团购一样
- **乐观锁防并发核销**：verifyOrder用 `.eq("status", 2)` 作为WHERE条件，保证同一张券不会被核销两次
- **type字段**：tb_voucher中 type=0是普通券，type=1是秒杀券，不是2

### 💡 重要认知

- 数据库旧数据不会自动更新，改了代码逻辑后要手动清理测试数据（UPDATE status=2）
- 支付流程不一定要接真实支付，模拟支付对学习项目来说已经能体现完整的订单状态机设计
- 前端隐藏按钮不等于安全，后端必须再校验一次（userId比对、status校验）

### ⏳ 下一步计划
- 重启后端测试完整流程：抢秒杀券 → 待支付 → 去支付 → 核销码 → verify.html核销
- 考虑是否加订单超时自动取消（15分钟不支付自动变status=4）

### 📂 代码位置
- `controller/VoucherOrderController.java` - 新增 /claim、/verify、/pay、/cancel 四个接口
- `service/IVoucherOrderService.java` - 新增 claimVoucher、verifyOrder、payOrder、cancelOrder
- `service/impl/VoucherOrderServiceImpl.java` - 四个方法实现，seckillVoucher改为status=1
- `controller/BlogController.java` - 新增 /search/title、/search/user
- `service/impl/BlogServiceImpl.java` - searchByTitle（多关键词OR+相关度排序）、searchByUser
- `html/hmdp/index.html` - 搜索栏+AI切换+emoji分类
- `html/hmdp/follow.html` - 两列瀑布流+搜索
- `html/hmdp/blog.html` - 搜索栏（标题/博主）
- `html/hmdp/blog-detail.html` - 店铺卡片
- `html/hmdp/profile.html` - 核销码展示+去支付+取消订单
- `html/hmdp/shop-detail.html` - 领券弹窗（核销码modal）
- `html/hmdp/verify.html` - 新建，商家核销页面

### 🎯 今天的收获
- 完整实现了优惠券从领取到核销的全链路：领券→支付→出示码→商家核销
- 理解了订单状态机设计，每个状态转换都有对应的业务含义
- 前端交互体验提升：搜索、瀑布流、弹窗、一键复制

---

## 2026-02-26 学习记录（晚上）

### ✅ 今天完成

1. **AI语义搜索功能（向量数据库）**
   - 集成智谱AI Embedding API，把商铺文字描述转成1024维向量
   - 集成Qdrant向量数据库，存储和检索向量
   - 实现 `GET /shop/search?q=关键词` 接口，支持语义搜索
   - 测试：搜"火锅涮肉"，前4名全是火锅类店铺，搜索准确

2. **Redis持久化配置**
   - 创建 `D:\redis\redis.conf`，配置RDB持久化
   - 数据目录 `D:\redis\data\`，重启后自动恢复
   - 解决了每次重启数据丢失的问题

3. **启动脚本升级**
   - `start-nginx-safe.bat` 加入Qdrant自动启动
   - `stop-nginx.bat` 加入Qdrant停止逻辑
   - 现在双击脚本自动启动：Qdrant + Redis + Nginx

### 📝 关键理解

- **语义搜索 vs 关键词搜索**：关键词搜索靠文字匹配，语义搜索靠向量相似度。"铜锅涮羊肉"和"火锅"没有共同词，但向量距离很近，所以能搜出来
- **向量数据库（Qdrant）**：把文字变成一组数字（向量），搜索时比较数字的"距离"，距离近=语义相似
- **Embedding API**：把文字转成向量的过程，同类事物的向量在空间上距离近
- **持久化**：Redis用RDB（定期快照到dump.rdb），Qdrant用storage目录，两者重启都不丢数据

### 💡 重要认知

- DeepSeek没有Embedding模型（只有对话模型），换用智谱AI的embedding-2解决
- 向量维度必须一致：集合创建时是1536维，插入1024维会报错。删掉重建就好
- 测试方法只需跑一次：loadShopGeoData() 和 loadShopVectors() 数据持久化后不需要再跑

### ⏳ 下一步计划
- 把今天的代码自己看一遍，理解EmbeddingService和QdrantService的原理
- 秒杀模块还没完成，后续继续

### 📂 代码位置
- `service/impl/EmbeddingService.java` - 调用智谱AI API，文字→向量
- `service/impl/QdrantService.java` - 操作Qdrant，建集合/存向量/查向量
- `controller/ShopController.java` - 新增 GET /shop/search 接口
- `test/HmDianPingApplicationTests.java` - loadShopVectors() / resetShopCollection()
- `resources/application.yaml` - 加入deepseek（智谱）和qdrant配置
- `start-nginx-safe.bat` / `stop-nginx.bat` - 加入Qdrant启停

### 🎯 今天的收获
- 项目加入了真实的AI功能，不只是CRUD了
- 理解了RAG的核心流程：文字→向量→存储→检索
- 向量搜索的效果超出预期，语义理解准确

---

## 2026-02-26 学习记录（下午）

### ✅ 今天完成

1. **Feed流代码修复**
   - 发现AI昨晚写的代码有设计矛盾：写端往ZSet推数据，读端却查MySQL，ZSet白写了
   - 修复 `queryBlogOfFollow`：改为从 `feed:{userId}` ZSet 读博客ID，再去MySQL查详情
   - 理解了滚动翻页原理：用时间戳当游标，不用OFFSET，避免新内容插入导致重复

2. **理解Feed流和ZSet**
   - 普通翻页用位置（OFFSET），新内容插入顶部导致位置偏移，出现重复
   - 游标翻页用时间戳，只查"比上次最后一条更早"的内容，顶部变化不影响翻页
   - ZSet = 带权重的Set，自动排序。Feed流用时间戳当权重，天然支持按时间倒序翻页

3. **附近商户（Redis GEO）**
   - Redis GEO本质是ZSet，score存的是经纬度编码（GeoHash）
   - 按typeId分组存入 `shop:geo:{typeId}`，查询时用 `radius()` 按距离排序
   - 升级Redis 3.0 → 5.0（GEO命令需要3.2+），Windows用tporadowski/redis
   - 降级逻辑：GEO无数据或Redis不支持时，fallback查MySQL

4. **用户签到（Redis BitMap）**
   - BitMap把一个月31天映射成31个二进制位，1=签到，0=未签到
   - key: `sign:{userId}:{年月}`，offset=日期-1
   - `sign()`：SETBIT设置今天那位为1
   - `signCount()`：bitField读出本月到今天的位图整数，从最低位往前数连续1的个数

5. **Redis注册为后台服务 + 脚本更新**
   - 把Redis注册成Windows服务，不再需要手动开窗口
   - `start-nginx-safe.bat` 加入Redis启动逻辑
   - `stop-nginx.bat` 加入Redis停止逻辑

6. **缓存三大问题复习**
   - 穿透：查不存在的数据存空值；布隆过滤器是生产级防御
   - 击穿：互斥锁（等待，一致性好）vs 逻辑过期（不等待，实时性弱）
   - 雪崩：随机TTL错开过期时间

### 📝 关键理解

- Feed流游标翻页：不用"第几页"，用"上次最后一条的时间戳"，新内容插入顶部不影响翻页
- ZSet一句话：带权重的Set，自动排序，权重可以是时间戳、距离、分数等任何数字
- BitMap连续签到统计：读出位图整数，从最低位（今天）往右移，遇到0停止，count就是连续天数

### 💡 重要认知
- 今天大部分代码是AI实现的，自己主要在理解原理和提问
- 缓存三大问题能从底层推导出来了，不是死记硬背

### ⏳ 下一步计划
- 把今天AI实现的代码自己敲一遍（见"待敲代码清单"）
- 开始研究AI功能接入（DeepSeek + RAG）

### 📂 代码位置
- `service/impl/BlogServiceImpl.java` - queryBlogOfFollow 修复（ZSet读取）
- `service/impl/ShopServiceImpl.java` - queryShopByType（GEO附近商户）
- `service/IShopService.java` - queryShopByType接口声明
- `controller/ShopController.java` - queryShopByType加x/y参数
- `service/impl/UserServiceImpl.java` - sign() / signCount()
- `service/IUserService.java` - sign/signCount接口声明
- `controller/UserController.java` - /user/sign、/user/sign/count接口
- `test/HmDianPingApplicationTests.java` - loadShopGeoData()
- `start-nginx-safe.bat` / `stop-nginx.bat` - 加入Redis启停

### 🎯 今天的收获
- 黑马点评后端全部模块完成（8/8）
- 理解了Feed流、GEO、BitMap三种Redis数据结构的使用场景
- Redis从3.0升级到5.0，解决了GEO命令不支持的问题

---

## 2026-02-25 学习记录（下午）

### ✅ 今天完成

1. **修复登录 Bug（双拦截器架构）**
   - 根因：`LoginInterceptor` 里有 GET 请求直接 `return true` 的旁路，导致 ThreadLocal 永远没人存
   - 拆成两道拦截器：`RefreshTokenInterceptor`（order=0，`/**`，只负责存 ThreadLocal，永不拦截）+ `LoginInterceptor`（order=1，只守需要登录的路径）
   - 修改 `MvcConfig.java` 注册两个拦截器并设置 order

2. **点赞模块深入学习**
   - Redis Set 直接写（不是缓存），SADD/SREM 切换状态，MySQL 只存总数
   - `Boolean.TRUE.equals(isMember)` 防 null 安全
   - `setIsLike()` 需要 UserHolder 有值，双拦截器修复后才真正生效
   - `queryHotBlog` forEach 链：分页取博客 → 填作者 → 填 isLike

3. **评论删除功能**
   - 后端：`deleteComment`，权限校验（只能删自己的），删后 `comments - 1`（带 gt 防负数）
   - 前端：`queryComments` 返回 `userId`，只对自己的评论渲染删除按钮，DOM 移除 + 计数 -1

4. **好友关注模块**
   - 关注/取关：同时写 MySQL（持久化）+ Redis Set（为 SINTER 服务），两者是伙伴关系不是缓存
   - `remove(new QueryWrapper<>())` 而不是 `remove(query())`，修复 500 错误
   - 共同关注：`SINTER follow:{me} follow:{other}` 取交集
   - 关注按钮显示在博客详情页作者栏，作者名可点击跳转他人主页

5. **粉丝/关注数实时计算**
   - `UserInfo` 存储字段永远不更新，改为 `/user/info/{id}` 实时 COUNT tb_follow
   - `UserController` 注入 `IFollowService`，实时计算

6. **Bug 修复：个人主页返回键**
   - `profile.html` 返回按钮写死 `href="index.html"`，改为 `history.back()`
   - 从博客详情进入他人主页后，返回能正确回到博客详情

### 📝 关键理解

- **双拦截器的核心逻辑**：公开接口要同时支持游客（没 token 也能访问）和登录用户（带 token 享受额外信息如 isLike），只能让第一道永不拦截，第二道守需要登录的接口
- **Redis 直接写 vs 缓存**：缓存是 MySQL→Redis 的副本，用完要失效；关注/点赞是直接写 Redis，MySQL 和 Redis 各管各的，互为补充
- **删除时的权限边界**：后端必须再校验一次（userId 比对），不能只靠前端隐藏按钮
- **实时计算 vs 冗余字段**：简单业务用实时 COUNT，避免维护冗余字段的并发问题

### 💡 重要认知
- 今天的代码大部分是 AI 协助实现的，自己主要在理解和提问
- 修 bug 的过程中学到的比直接实现更扎实：每个 bug 都对应一个真实的技术原理

### ⏳ 下一步计划
- Feed 流（推流）：关注的人发新博客 → 推送到我的时间线（Redis ZSet 按时间排序）
- 附近商户（Redis GEO）
- 用户签到（Redis BitMap）

### 📂 代码位置
- `utils/RefreshTokenInterceptor.java` - 新建，双拦截器第一道
- `utils/LoginInterceptor.java` - 简化，只检查 ThreadLocal
- `config/MvcConfig.java` - 注册两个拦截器 + order
- `service/impl/BlogCommentsServiceImpl.java` - deleteComment，queryComments 加 userId
- `controller/BlogCommentsController.java` - DELETE /blog-comments/{id}
- `service/impl/FollowServiceImpl.java` - follow/isFollow/followCommons
- `controller/FollowController.java` - 三个接口
- `controller/UserController.java` - queryUserById + info 实时计算粉丝关注数
- `html/hmdp/blog-detail.html` - 关注按钮、作者跳转、评论删除
- `html/hmdp/profile.html` - 支持 ?id= 查看他人主页、返回键改为 history.back()

### 🎯 今天的收获
- 双拦截器架构是 Spring MVC 拦截器的经典用法，彻底理解了公开接口 + 识别登录的矛盾解法
- Redis Set 的 SINTER 命令让共同关注变成一行代码
- 任何涉及"自己才能操作"的功能，后端都要做权限校验

---

## 2026-02-24 学习记录（下午+深夜）

### ✅ 今天完成

1. **完成分布式锁替换**
   - 用 Redisson 替换 `synchronized`
   - pom.xml 加入 `redisson-spring-boot-starter 3.13.6`
   - 创建 `RedissonConfig.java` 配置类
   - `VoucherOrderServiceImpl` 改用 `RLock.tryLock()` + `finally unlock()`

2. **实现完整登录系统**
   - `UserServiceImpl` 实现 `sendCode`（固定验证码114514）和 `login`（Redis存token）
   - 创建 `LoginInterceptor`：从请求头取token → Redis验证 → 存入ThreadLocal → 续期
   - 创建 `MvcConfig`：注册拦截器，配置需要登录的接口路径
   - 前端 `login.html` 改为真实调后端接口，存真实token

3. **实现个人中心**
   - 后端加 `queryMyOrders()` 接口（关联优惠券标题）
   - 新建 `profile.html`：显示昵称、积分、会员等级、粉丝数、订单列表
   - 首页显示真实昵称，点击跳转个人中心

4. **实现点赞功能（Redis Set）**
   - `BlogServiceImpl` 实现 `likeBlog`：SISMEMBER判断 → SADD/SREM切换 + MySQL liked±1
   - `queryHotBlog` 和 `queryBlogById` 顺带设置 `isLike` 字段
   - Controller 逻辑移入 Service 层（规范分层）

5. **新建探店笔记页面**
   - `blog.html`：瀑布流列表、点赞按钮（红心切换）、评论区展开/收起
   - 首页加"探店笔记"入口

6. **实现评论功能**
   - `BlogCommentsServiceImpl` 实现 `queryComments`（关联用户昵称）和 `saveComment`
   - `BlogCommentsController` 加 GET/POST 接口
   - 前端评论区：展开加载、发送评论、实时刷新

### 📝 关键理解

- **Redisson 看门狗**：`leaseTime=-1` 时启动，每10秒续期，业务完成调 `unlock()` 停止，宕机则自然过期
- **登录拦截器**：不是 `@Autowired`，由 MvcConfig 手动 `new` 传入 StringRedisTemplate
- **点赞用 Redis Set 不是缓存**：不是从MySQL复制过来的，是用户点赞那一刻直接写进去的，MySQL只存总数，Redis存谁点了
- **finally 释放锁**：保证业务抛异常时锁也能释放，防死锁

### 💡 重要认知
- 今天代码基本是AI写的，自己没有动手，理解了流程但没有肌肉记忆
- 下次要自己照着写一遍，特别是登录拦截器和点赞这两块

### ⏳ 下一步计划
- 自己照着写一遍登录拦截器（费曼实践）
- 改造 blog.html 为小红书两列瀑布流布局
- 继续后端：好友关注模块（Redis Set 交集）

### 📂 代码位置
- `config/RedissonConfig.java` - Redisson配置
- `config/MvcConfig.java` - 拦截器注册
- `utils/LoginInterceptor.java` - 登录拦截器
- `service/impl/UserServiceImpl.java` - 登录逻辑
- `service/impl/VoucherOrderServiceImpl.java` - 分布式锁秒杀
- `service/impl/BlogServiceImpl.java` - 点赞逻辑
- `service/impl/BlogCommentsServiceImpl.java` - 评论逻辑
- `html/hmdp/blog.html` - 探店笔记页面
- `html/hmdp/profile.html` - 个人中心页面

---

## 2026-02-23 学习记录（下午+晚上）

### ✅ 今天完成
1. 复习缓存三大问题（穿透/击穿/雪崩）
2. 理解分布式锁完整演进过程

### 📝 关键理解
- `synchronized` 锁在JVM内存里，只对本台服务器有效，多台服务器时失效
- 分布式锁用Redis实现，因为Redis是所有服务器共享的，且比数据库快100倍
- SETNX：key不存在才写入，写成功=拿到锁，写失败=没拿到锁
- 释放锁要带UUID标识，防止误删别人的锁
- 查询+删除两步操作用Lua脚本打包成原子操作
- Redisson看门狗：每10秒检查业务是否完成，未完成自动续期30秒，宕机则停止续期

### 💡 重要认知
- 定时轮询检查状态是计算机里的通用模式（看门狗、心跳检测、进程调度）
- 原子性问题的解决思路：数据库靠单条SQL，Redis靠Lua脚本

### ⏳ 下一步
- 看Redisson的代码实现
- 用分布式锁替换秒杀里的synchronized

---

## 2026-02-16 学习记录（下午+晚上）

### ✅ 今天完成
1. **发现学习中的核心问题**
   - 意识到缺少Java Web开发的整体认知框架
   - 不理解项目结构（src、pom.xml、target）
   - 不会用IDEA调试代码
   - 看不懂报错信息
   - Java基础薄弱（Lambda、泛型、注解）

2. **制定阶段0学习计划**
   - 目标：补基础工具知识
   - 预计1-2天完成
   - 方法：边学边练，不系统学习

3. **整理docs文件夹**
   - 创建"个人设定"文件夹
   - 创建"疑问记录.md"
   - 创建"知识盲区.md"
   - 移动相关文件到合适位置
   - 更新"学习计划.md"，加入阶段0

4. **发现并解决项目启动问题**
   - 问题：IDEA启动"Start All Services"后，前端页面显示"店铺加载失败"
   - 原因：每次启动都创建新nginx进程，导致10个nginx同时监听8080端口
   - 解决：创建安全启动脚本，检查nginx是否已运行
   - 修复：修改IDEA运行配置，调用安全脚本

5. **创建完整的启动脚本体系**
   - start-project.bat：一键启动（检查MySQL+Redis+启动nginx）
   - start-nginx-safe.bat：安全启动nginx（避免重复启动）
   - stop-nginx.bat：优雅停止nginx
   - 修改IDEA配置：Start_Nginx.xml、Stop_Nginx.xml
   - 创建README-启动说明.md文档

6. **清理环境**
   - 强制停止12个冗余的nginx进程
   - 释放8080端口
   - 验证环境干净

7. **解决MySQL连接问题**
   - 遇到错误：Public Key Retrieval is not allowed
   - 原因：MySQL 8.0使用新认证方式，但驱动是5.1.47老版本
   - 解决：在application.yaml的URL中添加 `&allowPublicKeyRetrieval=true`
   - 项目成功运行，前端显示店铺列表

8. **开始学习秒杀代码**
   - 确定学习方法：逐行讲解（详细解释方法名，但不解释if/for等基础语法）
   - 创建代码学习模板（docs/代码学习模板.md）

9. **学习秒杀代码（检查阶段：第38-55行）**
   - 第38-40行：查询优惠券信息（getById方法，MyBatis-Plus）
   - 第42-45行：判断秒杀是否开始（isAfter方法，LocalDateTime）
   - 第47-50行：判断秒杀是否结束（isBefore方法）
   - 第52-55行：快速库存检查（理解这不是防超卖的核心）

10. **深入理解方法调用链（链式调用）**
    - 理解 `voucher.getBeginTime().isAfter(LocalDateTime.now())` 的执行过程
    - 从左到右依次执行：对象 → 方法1返回对象 → 方法2
    - 拆解写法 vs 链式写法
    - 理解链式调用的优点：简洁、可读性好

11. **学习核心逻辑（一人一单：第58-70行）**
    - `UserHolder.getUser().getId()` 获取当前用户ID
    - `synchronized (userId.toString().intern())` 加锁防止一人多单
    - 理解 `.intern()` 的作用：字符串常量池，保证相同字符串指向同一对象
    - 理解synchronized锁的范围：同一用户的请求排队，不同用户不影响
    - `query().eq().eq().count()` 查询用户是否已购买

12. **学习核心逻辑（乐观锁防超卖：第73-81行）**
    - MyBatis-Plus的链式UPDATE：`.update().setSql().eq().gt().update()`
    - 生成SQL：`UPDATE ... SET stock = stock - 1 WHERE voucher_id = ? AND stock > 0`
    - **核心：`.gt("stock", 0)` 是乐观锁的关键**
    - 理解数据库行锁机制：检查WHERE条件和执行SET操作是原子的
    - 场景模拟：库存=1，两个线程同时抢，只有一个成功
    - 理解为什么第52行的快速检查无法防超卖（并发读取问题）

### 📝 关键理解

#### 秒杀代码的整体流程
秒杀代码分为两大阶段：
1. **检查阶段（38-55行）**：快速拦截不符合条件的请求
   - 查询优惠券
   - 判断时间（开始、结束）
   - 快速库存检查
2. **核心逻辑（58-81行）**：防止一人多单 + 防止超卖
   - synchronized锁：防止一人多单
   - 乐观锁：防止超卖

#### 方法调用链（链式调用）
```java
voucher.getBeginTime().isAfter(LocalDateTime.now())
```
执行过程：
1. `voucher.getBeginTime()` → 返回LocalDateTime对象
2. 在返回的对象上调用 `.isAfter(参数)`
3. `LocalDateTime.now()` 作为参数传入
4. 返回boolean结果

**关键：方法返回对象，对象可以继续调用方法**

#### synchronized锁（防一人多单）
```java
synchronized (userId.toString().intern()) {
    // 查询是否已购买
    // 扣减库存、创建订单
}
```

**核心理解：**
- 锁对象是 `userId.toString().intern()`
- `.intern()` 保证相同内容的字符串指向同一个对象
- 同一用户的多个请求锁同一个对象 → 排队执行
- 不同用户锁不同对象 → 不互相影响

**为什么需要synchronized？**
- 防止同一用户手抖点两次，创建两个订单
- 线程A查到count=0，线程B也查到count=0 → 都创建订单
- 加锁后：线程A查询→创建，线程B再查询时count=1 → 拒绝

#### 乐观锁（防超卖核心）
```java
seckillVoucherService.update()
    .setSql("stock = stock - 1")
    .eq("voucher_id", voucherId)
    .gt("stock", 0)  // ← 核心
    .update();
```

**生成的SQL：**
```sql
UPDATE tb_seckill_voucher
SET stock = stock - 1
WHERE voucher_id = ? AND stock > 0
```

**核心理解：**
- `.gt("stock", 0)` 不是查询条件，是UPDATE的WHERE条件
- 意思是：只有库存>0的记录才执行UPDATE
- 数据库行锁机制：检查WHERE条件 + 执行SET操作是原子的

**为什么能防超卖？**
```
库存=1，线程A和B同时到达

线程A：UPDATE ... WHERE stock > 0
  → 数据库加锁 → 检查stock>0(满足) → stock-1 → 释放锁
  → 影响行数：1（成功）

线程B：UPDATE ... WHERE stock > 0
  → 数据库加锁 → 检查stock>0(不满足，此时stock=0) → 不执行SET
  → 影响行数：0（失败）
```

**Java代码判断：**
- `boolean success = ...update()`
- `success = true`：影响1行，扣减成功
- `success = false`：影响0行，扣减失败 → 返回"库存不足"

#### 快速库存检查 vs 乐观锁
**第52行的快速检查（`if (voucher.getStock() < 1)`）：**
- 作用：性能优化，库存明显=0时快速返回
- 无法防超卖：两个线程可能同时读到stock=1，都通过检查

**第76行的乐观锁（`.gt("stock", 0)`）：**
- 作用：真正防超卖
- 原理：数据库行锁 + WHERE条件原子性

#### 两把锁的区别
| 锁类型 | 位置 | 作用 | 锁的范围 | 实现层面 |
|--------|------|------|----------|----------|
| synchronized锁 | 第61行 | 防止一人多单 | 同一用户的多个请求 | Java代码层面 |
| 乐观锁 | 第76行 | 防止超卖 | 所有用户竞争同一个券 | 数据库层面 |

#### 学习困境的本质
- 学校只教了"砖头"（语法：if、for、类、对象）
- 但从来没教"怎么建房子"（项目结构、构建流程、运行机制）
- 这导致我会写简单语法，但看不懂项目代码

#### Java Web开发知识体系
分为4个层次：
1. **第0层：开发环境和工具**（我最缺的）
   - JDK、IDEA、Maven、项目结构
2. **第1层：Java语言基础**
   - 基本语法、面向对象、常用API
3. **第2层：Java Web基础**
   - Servlet、Spring、Spring MVC、Spring Boot
4. **第3层：数据库和中间件**
   - MySQL、Redis、MyBatis-Plus

#### 知识盲区的优先级
- 🔴 高优先级：工具和环境（严重影响当前学习）
- 🟡 中优先级：Java进阶（影响代码理解）
- 🟢 低优先级：Java底层（深入理解用）

### 💡 重要认知
- **我的问题不是"学太深了"，而是"缺少实战的基础工具知识"**
- 这些知识不属于理论，而是"怎么干活的工具"
- 就像木匠要学怎么用锤子，厨师要学怎么用刀
- 我现在是"知道菜谱（理论），但不会用刀（工具）"

### 🤔 待解决的疑问
- ~~Q5: 为什么IDEA启动项目后，前端页面显示"店铺加载失败"？~~ ✅ 已解决
  - 原因：重复启动nginx导致端口冲突
  - 解决：创建安全启动脚本
- ~~Q13: MySQL连接报错"Public Key Retrieval is not allowed"~~ ✅ 已解决
  - 原因：MySQL 8.0认证方式与老驱动不兼容
  - 解决：添加 `allowPublicKeyRetrieval=true` 参数

### ⏳ 下一步计划

#### 秒杀模块（继续）
1. **完成秒杀代码学习**（下次）
   - 第84-98行：创建订单部分
   - 理解全局唯一ID生成器（RedisIdWorker）
   - 整体回顾和总结

2. **实践验证**（之后）
   - 用IDEA调试，单步执行看流程
   - 在关键位置打断点（第63行、第73行）
   - 查看变量值（userId、count、success）
   - 理解代码实际执行过程

3. **测试超卖和一人一单**（可选）
   - 用JMeter模拟高并发
   - 验证乐观锁是否真的防超卖
   - 验证synchronized是否真的防一人多单

#### 阶段0：补基础工具（穿插进行）
- 在学习秒杀的过程中，已经开始学习调试
- 理解了Maven依赖（MySQL驱动问题）
- 理解了项目配置（application.yaml）
- 下次学习时用断点调试验证理解

### 📂 代码位置

#### 秒杀代码
- `VoucherOrderServiceImpl.java` 第38-98行
  - 第38-40行：查询优惠券
  - 第42-45行：判断开始时间
  - 第47-50行：判断结束时间
  - 第52-55行：快速库存检查
  - 第58-70行：一人一单（synchronized锁）
  - 第73-81行：扣减库存（乐观锁）
  - 第84-98行：创建订单（下次学习）

#### 配置文件
- `application.yaml` 第8行：添加了 `allowPublicKeyRetrieval=true`

#### 启动脚本（项目根目录）
- `start-project.bat` - 一键启动脚本（检查环境+启动nginx+提示）
- `start-nginx-safe.bat` - 安全启动nginx（带重复检查）
- `stop-nginx.bat` - 优雅停止nginx

#### IDEA运行配置
- `.idea/runConfigurations/Start_Nginx.xml` - 修改为调用安全脚本
- `.idea/runConfigurations/Stop_Nginx.xml` - 修改为调用优雅停止脚本
- `.idea/runConfigurations/Start_All_Services.xml` - 复合配置（无需修改）

#### 文档
- `README-启动说明.md` - 完整的启动说明文档
- `docs/疑问记录.md` - 记录了启动问题
- `docs/知识盲区.md` - 知识盲区清单
- `docs/学习计划.md` - 加入阶段0计划

### 🎯 今天的收获

#### 项目启动和环境
- **找到了学习困境的根本原因**：缺少工具知识，不是学太深了
- **制定了明确的补救计划**：阶段0学习（补基础工具知识）
- **整理了学习文档体系**：
  - 创建"疑问记录.md"（按科目分类）
  - 创建"知识盲区.md"（按优先级分类）
  - 更新"学习计划.md"（加入阶段0）
  - 规范"学习进度.md"（统一记录格式）
  - 创建"个人设定"文件夹
- **建立了清晰的知识体系**：4层结构（工具→语言→框架→中间件）
- **明确了学习优先级**：先学工具（调试、项目结构），再学理论
- **解决了项目启动问题**：
  - 诊断出重复启动nginx的问题（12个进程！）
  - 创建3个启动脚本（安全启动、优雅停止、一键启动）
  - 修复IDEA运行配置（不再重复启动）
  - 清理环境，释放端口
- **掌握了脚本编写技能**：
  - bat脚本语法（检查进程、条件判断、错误处理）
  - IDEA运行配置修改（XML配置）
  - Windows进程管理（tasklist、taskkill、netstat）

#### 秒杀业务代码学习
- **确定了适合自己的学习方法**：
  - 逐行讲解，详细解释方法名和对象
  - 不解释基础语法（if、for等）
  - 创建了代码学习模板（docs/代码学习模板.md）

- **深入理解了秒杀代码结构**：
  - 检查阶段（快速拦截）
  - 核心逻辑（一人一单 + 防超卖）
  - 两个阶段的作用和区别

- **掌握了方法调用链（链式调用）**：
  - 理解执行顺序（从左到右）
  - 理解每个方法的返回值
  - 会拆解链式调用（方便理解）
  - 常见场景：MyBatis-Plus查询、Stream流式操作

- **深入理解了synchronized锁**：
  - 作用：防止同一用户重复购买（一人一单）
  - 锁对象：`userId.toString().intern()`
  - `.intern()` 的作用：字符串常量池，保证相同字符串指向同一对象
  - 锁的范围：同一用户排队，不同用户不影响
  - 为什么需要：防止并发查询导致的一人多单

- **深入理解了乐观锁（防超卖核心）**：
  - `.gt("stock", 0)` 是UPDATE的WHERE条件，不是查询条件
  - 生成SQL：`UPDATE ... WHERE stock > 0`
  - 数据库行锁机制：检查WHERE + 执行SET是原子操作
  - 为什么能防超卖：只有一个线程的UPDATE会成功（影响1行）
  - 其他线程的UPDATE会失败（影响0行，因为stock已经=0）

- **理解了快速检查 vs 乐观锁的区别**：
  - 快速检查（第52行）：性能优化，无法防超卖
  - 乐观锁（第76行）：真正防超卖的核心
  - 区别：快速检查是并发读取，乐观锁是原子操作

- **掌握了MyBatis-Plus的用法**：
  - `getById(id)` 根据主键查询
  - `query().eq().eq().count()` 条件查询统计
  - `update().setSql().eq().gt().update()` 链式UPDATE
  - 理解每个方法的返回值类型

- **理解了Java 8日期时间API**：
  - `LocalDateTime` 本地日期时间类
  - `LocalDateTime.now()` 获取当前时间
  - `isAfter()` 判断是否在某时间之后
  - `isBefore()` 判断是否在某时间之前

- **理解了两把锁的配合**：
  - synchronized锁：防止一人多单（Java代码层面）
  - 乐观锁：防止超卖（数据库层面）
  - 两者配合使用，解决不同的问题

---

## 2026-02-23 学习记录（凌晨）

### ✅ 今天完成

1. **理解 ThreadLocal 原理**
   - 每个线程独立存储一份数据，互不干扰
   - UserHolder.getUser() 取的是当前线程自己存的用户，不需要传参
   - 请求进来时拦截器存入，请求结束后必须 removeUser() 清掉

2. **理解 MyBatis-Plus 链式构造器**
   - 本质是在 Java 里拼 SQL 字符串
   - setSql/eq/gt 只是往构造器里加内容，最后 .update() 才真正发给数据库执行
   - 书写顺序不代表执行顺序，SQL 执行顺序由数据库决定（先 WHERE 判断，再 SET 执行）

3. **深入理解乐观锁 vs 悲观锁**
   - 悲观锁：看到锁直接等，整个业务流程排队（连按钮都不给按）
   - 乐观锁：大家都去试，数据库行锁保证只有一个人成功（可以按按钮，但生不生效数据库说了算）
   - 原子性靠的是数据库行锁，不是时间短
   - 乐观锁等待时间只有 UPDATE 那一瞬间，悲观锁等待整个业务流程

4. **理解两把锁各管各的问题**
   - synchronized：防一人多单（Java 层面，锁住整个查询+创建订单流程）
   - 乐观锁：防超卖（数据库层面，只锁 UPDATE 那一步）

5. **乐观锁的缺陷**
   - 高并发冲突多时失败率高，明明有库存却买不到
   - 悲观锁在冲突多的场景下反而更稳定，每个线程都能成功

### ⏳ 下一步计划
- 继续秒杀模块后续内容（分布式锁）

---

## 2026-02-18 学习记录（凌晨）

### ✅ 今天完成

1. **纠正了两个概念误区**
   - 登录 ≠ 拦截器查Redis：登录是写入Redis，拦截器是查Redis验证Token
   - 后端不做渲染：后端只返回JSON数据，前端拿数据自己渲染

2. **学会用F12看网络请求**
   - 网络面板里看到三条请求：localhost(304)、list(200)、list?current=1&pageSize=12(200)
   - 200 = 成功，304 = 从缓存读取
   - 点开请求 → 预览 → 看到后端返回的JSON数据
   - 验证了前后端分离：后端只返回 {success, data}，前端负责渲染

3. **找到Controller代码对应的请求**
   - F12看到 list?current=1&pageSize=12
   - 在ShopController里找到 @GetMapping("/list") 方法
   - 理解了URL参数如何映射到Java方法参数（current=1, pageSize=12）

4. **学会打断点和看变量**
   - 在 return Result.ok(page) 这行打断点
   - 用Debug模式启动项目
   - 刷新浏览器触发断点，程序暂停，页面卡住等待
   - 在Variables窗口看到page里的真实数据（total、size=12、records）
   - 按F9让程序继续，页面恢复

5. **学会看日志**
   - 日志格式：`==> Preparing:` SQL语句，`==> Parameters:` 参数，`<== Total:` 结果数量
   - ERROR日志：`错误类型: 错误原因`

6. **学会看报错和排查链路**
   - 故意写 `1/0` 制造 ArithmeticException: / by zero
   - IDEA控制台出现 ERROR 日志
   - F12网络面板看到失败请求返回 {success: false, errorMsg: "服务器异常"}
   - 前端显示"加载失败"
   - 理解了完整报错链路

### 📝 关键理解
**注意：需要用自己的话写进这里才算真正学会**

待阐述：
1. 前后端分离是什么意思，后端返回的是什么
2. 打断点的目的是什么，为什么页面会卡住
3. 看报错的步骤是什么

### 💡 重要认知
- 调试不是玄学，就是在某一行暂停，亲眼看内存里的真实数据
- 遇到报错先看F12网络面板找失败请求，再去IDEA找ERROR日志
- 日志是后端的"监控录像"，不用猜，直接看

### 🤔 待解决的疑问
- WebExceptionAdvice是什么？全局异常处理器是怎么工作的？（下次学习）
- Stack Trace堆栈信息还没看，下次学

### ⏳ 下一步计划
1. 用自己的话阐述今天的内容（费曼学习法）
2. 学会看Stack Trace（堆栈信息，定位报错在哪一行代码）
3. 继续秒杀代码的学习（RedisIdWorker代码实现）

### 📂 代码位置
- `ShopController.java` - queryShopList() 方法，打了断点练习
- `WebExceptionAdvice.java` - 全局异常处理器（下次学习）
- `docs/代码学习模板.md` - 已更新教学方法

### 🎯 今天的收获
- 第一次真正用F12看到了前后端数据传输的过程
- 第一次成功打断点并看到了内存里的变量值
- 第一次主动制造报错并完整走了排查流程
- 建立了"遇到问题怎么排查"的基本流程

---

## 2026-02-17 学习记录（晚上）

### ✅ 今天完成
1. **调整学习方法**
   - 发现之前的教学方式太繁琐（逐行讲解创建对象、set属性）
   - 修改了代码学习模板（docs/代码学习模板.md）
   - 调整为：基础操作合并讲解，重点讲解关键技术点
   - 更符合深度理解型学习者的习惯

2. **学习秒杀代码的创建订单部分（第84-98行）**
   - 理解了为什么需要全局唯一ID（数据库自增ID的缺陷）
   - 对比了3种方案：数据库自增、UUID、Redis自增
   - 选择Redis的原因：全局唯一、高性能、数字类型、趋势递增

3. **深入理解RedisIdWorker原理（从原理层面）**
   - Redis单线程模型 + INCR原子操作 → 保证不冲突
   - ID结构：时间戳（31位）+ 序列号（32位）
   - 时间戳保证"不同时间"生成的ID不重复
   - 序列号保证"同一时间"生成的ID不重复（Redis INCR）
   - 按天分组的原因：统计方便、防止计数器过大、便于清理

### 📝 关键理解
**注意：这部分需要用自己的话阐述，今天还没完全理解，下次继续**

待阐述的问题：
1. 为什么数据库自增不行？
2. Redis凭什么能保证全局唯一？
3. 时间戳+序列号的组合为什么能保证唯一？

### 💡 重要认知
- **学习方法调整**：基础操作不需要逐行讲解，重点应该放在关键技术点的原理上
- **先理解原理，再看代码**：直接看代码容易懵，应该先理解为什么这样设计，再看具体实现
- **Redis的核心优势**：单线程模型 + 原子操作 + 内存存储 → 高性能且保证唯一性

### 🤔 待解决的疑问
- Redis的INCR命令底层是怎么实现的？（不急，暂时理解原理即可）
- 为什么时间戳要左移32位？位运算的原理是什么？（下次学习）
- 如果Redis宕机了怎么办？（分布式系统的问题，暂不深入）

### ⏳ 下一步计划
1. **用自己的话阐述RedisIdWorker原理**（费曼学习法）
   - 为什么数据库自增不行
   - Redis如何保证全局唯一
   - 时间戳+序列号的设计思路

2. **看RedisIdWorker的代码实现**
   - 理解位运算（左移、或运算）
   - 理解代码的每一步操作

3. **完成秒杀代码的学习**
   - 整体回顾秒杀流程
   - 总结三个核心技术点

4. **实践调试**（阶段0目标）
   - 用IDEA打断点
   - 单步执行秒杀代码
   - 验证理解

### 📂 代码位置
- `VoucherOrderServiceImpl.java` 第84-98行：创建订单部分
- `RedisIdWorker.java`：全局唯一ID生成器（下次详细看）
- `docs/代码学习模板.md`：已更新教学方法

### 🎯 今天的收获
- 调整了学习方法，更高效了
- 理解了为什么需要全局唯一ID（分布式系统的问题）
- 理解了Redis能做到全局唯一的原理（单线程+原子操作）
- 理解了ID的设计思路（时间戳+序列号）

---

## 2026-02-12 学习记录（凌晨）

### ✅ 今天完成
1. **解决项目启动问题**
   - 修复MySQL驱动配置问题（com.mysql.cj.jdbc.Driver → com.mysql.jdbc.Driver）
   - 启动nginx前端服务
   - 配置IDEA一键启动（Start All Services）
   - 项目成功运行，可以访问 http://localhost:8080

2. **学习优惠券秒杀模块（理论部分）**
   - 理解了秒杀业务场景：商家发布限量优惠券，用户抢购
   - 理解了三个核心问题：
     - 超卖问题：并发导致库存变负数
     - 一人一单问题：黄牛刷单
     - 性能问题：数据库压力过大
   - 理解了数据库表结构：
     - tb_voucher：优惠券基本信息
     - tb_seckill_voucher：秒杀信息（库存、时间）
     - tb_voucher_order：订单记录

3. **深入理解超卖问题的底层原理**
   - 超卖原因：并发导致信息不共享，读取和修改不是原子操作
   - 解决方案：乐观锁（在UPDATE时加 WHERE stock > 0 条件）
   - 数据库保证：行锁机制，检查和修改是原子操作
   - 关键理解：不是异步，是同步机制（数据库的行锁）

4. **实现基础秒杀代码（会超卖的版本）**
   - 创建了 RedisIdWorker 工具类（生成全局唯一ID）
   - 实现了 VoucherOrderServiceImpl.seckillVoucher 方法
   - 实现了完整的秒杀流程：
     1. 查询优惠券信息
     2. 判断秒杀时间是否有效
     3. 判断库存是否充足
     4. 扣减库存（⚠️ 会超卖）
     5. 创建订单
     6. 返回订单ID

### 📝 关键理解

#### 超卖问题
- **产生原因**：线程A和线程B同时读取 stock = 1，都认为有库存，都执行扣减，导致 stock = -1
- **底层原理**：并发、非原子操作、信息不共享
- **解决方案**：数据库行锁 + WHERE stock > 0 条件

#### 乐观锁 vs 悲观锁
- **悲观锁**：排队执行，性能差，不会冲突
- **乐观锁**：不排队，性能好，失败了就重试或放弃
- **秒杀场景**：用乐观锁（失败了就返回"库存不足"）

#### 数据库行锁机制
- UPDATE语句执行时，数据库会自动给这一行加锁
- 检查 WHERE 条件和执行 SET 操作是原子的，不可分割
- 其他线程必须等待锁释放后才能执行
- 这就是数据库的原子性保证

#### 全局唯一ID生成器
- 组成：时间戳（31bit） + 序列号（32bit）
- 时间戳：当前时间 - 开始时间（2022-01-01）
- 序列号：Redis自增，按天分组（icr:order:2026:02:12）
- 优点：不会重复，不会被猜到订单量

### 💡 重要认知
- 超卖问题的本质是并发问题，不是代码逻辑问题
- 数据库的行锁是同步机制，不是异步
- 一条SQL语句的执行是原子操作
- 乐观锁适合秒杀场景（冲突多，但失败了就失败了）

### ⏳ 下一步计划
1. **修复超卖问题**
   - 在UPDATE语句中添加 WHERE stock > 0 条件
   - 测试验证是否还会超卖

2. **实现一人一单功能**
   - 查询用户是否已经购买过
   - 用synchronized实现单机锁
   - 发现分布式环境下的问题

3. **实现分布式锁**
   - 用Redis实现分布式锁
   - 解决分布式环境下的一人一单问题

4. **异步秒杀优化**
   - 用Lua脚本 + 消息队列优化性能

### 📂 代码位置
- `VoucherOrderServiceImpl.java` - seckillVoucher() 秒杀主流程
- `VoucherOrderController.java` - 秒杀接口
- `RedisIdWorker.java` - 全局唯一ID生成器
- `application.yaml` - 数据库配置（已修复）

### 🎯 今天的收获
- 理解了秒杀业务的核心问题和解决思路
- 深入理解了超卖问题的底层原理（并发、原子性、行锁）
- 理解了乐观锁和悲观锁的区别
- 实现了基础秒杀代码（虽然会超卖，但理解了原理）
- 学会了用数据库的行锁机制解决并发问题

### 🤔 待解决的疑问
- 如何测试超卖问题？（需要模拟高并发）
- 一人一单怎么实现？（下次学习）
- 分布式锁的原理是什么？（下次学习）

---

## 2026-02-09 学习记录（晚上）

### ✅ 今天完成
1. **重新理解项目整体架构**
   - 理解了黑马点评的目的：仿大众点评的本地生活服务平台
   - 理解了为什么需要Redis：28定律，热点数据缓存
   - 理解了请求流程：前端 → Controller → Service → Redis/MySQL → 返回
   - 类比：MySQL=硬盘（慢但容量大），Redis=内存（快但容量小）

2. **缓存雪崩**：随机过期时间方案（已实现）
   - 理解了问题：大量key同时过期 → 数据库瞬时压力过大
   - 理解了解决方案：给过期时间加随机值，时间错位，分散过期
   - 代码实现：`randomTTL = CACHE_SHOP_TTL + new Random().nextInt(5)`
   - 学习了Java Random API：`nextInt(5)`生成[0,5)，不是[-5,5]

3. **逻辑过期方案**：解决缓存击穿的另一种方法（代码已实现，理解中）
   - 理解了核心思想：不等待，返回旧数据，异步更新
   - 理解了与互斥锁的区别：
     - 互斥锁：等待新数据，保证一致性，性能差
     - 逻辑过期：不等待，返回旧数据，性能好，一致性弱
   - 学习了线程池的概念：提前创建好线程，重复使用，避免多次创建和销毁
   - 代码位置：`ShopServiceImpl.java` - queryWithLogicalExpire(), saveShop2Redis()

4. **小说创作**
   - 构建了完整的魔法体系设定
   - 创建了设定文档：`docs/格外小说/魔法体系设定.md`
   - 核心设定：共生体系统、能量来源、魔法使用、社会影响

5. **发现的问题**
   - 代码实践能力弱：黑马项目一行代码都没写过
   - Java基础不牢固：对API不熟悉，对线程池等概念不熟悉
   - 学习方法问题：只理解不实践，导致"看懂但写不出"

6. **创建了学习习惯文档**
   - 记录了我的学习风格：深度理解型学习者
   - 记录了学习方法：目的导向 → 整体框架 → 费曼学习 → 间歇复习
   - 记录了当前问题和解决方案

### 📝 关键理解
- **缓存穿透**：查不存在的数据 → 存空值（2分钟过期）
- **缓存击穿**：热点key过期 → 互斥锁（SETNX），只让一个线程重建缓存
- **缓存雪崩**：大量key同时过期 → 随机过期时间，时间错位
- **逻辑过期**：不设置TTL，在数据中存储逻辑过期时间，异步更新，返回旧数据
- **线程池**：提前创建好线程，重复使用，避免多次创建和销毁
- **28定律**：80%的请求访问20%的热门数据

### 💡 重要认知
- 看懂 ≠ 学会，必须通过实践才能真正掌握
- 不要积累模糊知识点，每个都要理解透彻
- 学习要"先建一楼，再建二楼"，不能反过来
- 架构师也需要深入理解代码实现
- 兴趣广泛是好事，但需要聚焦在当前最重要的事情上

### ⏳ 下一步计划
1. **完成逻辑过期方案的学习**（明天）
   - 理解queryWithLogicalExpire方法的完整流程
   - 测试逻辑过期方案的效果
   - 对比互斥锁和逻辑过期的性能差异

2. **补充Java基础知识**
   - 线程和线程池
   - 异步编程
   - Lambda表达式

3. **代码实践**
   - 照着写一遍逻辑过期方案的代码
   - 修改参数看效果

4. **继续学习后续模块**
   - 优惠券秒杀
   - 点赞功能
   - 好友关注

### 📂 代码位置
- `ShopServiceImpl.java` - queryWithPassThrough(), queryWithMutex(), queryWithLogicalExpire()
- 第80-82行和第131-133行：缓存雪崩解决方案
- 第165-220行：逻辑过期方案
- `docs/我的学习习惯.txt` - 学习习惯记录
- `docs/格外小说/魔法体系设定.md` - 小说设定

### 🎯 今天的收获
- 完成了商户查询缓存模块的大部分内容
- 理解了Redis缓存的三大问题和解决方案
- 学习了线程池的概念
- 构建了完整的小说魔法体系
- 明确了自己的学习风格和发展方向

---

## 2026-02-08 学习记录

### ✅ 今天完成
1. 环境搭建（MySQL、Redis、前端nginx、后端Spring Boot）
2. 基础缓存实现（Cache Aside Pattern）
3. **缓存穿透**：缓存空对象方案（已实现）
4. **缓存击穿**：互斥锁方案（已实现）

### 📝 关键理解
- 缓存穿透：查不存在的数据 → 存空值（2分钟过期）
- 缓存击穿：热点key过期 → 互斥锁（SETNX）
- 锁是针对同一个key的（id=1用lock:shop:1）

---

**最后更新：** 2026-02-16 下午
