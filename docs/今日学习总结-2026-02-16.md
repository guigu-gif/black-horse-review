# 今日学习总结

> 日期：2026-02-16（下午+晚上）
> 学习时长：约5小时
> 主题：项目启动问题解决 + 秒杀代码深入学习

---

## ✅ 今天完成的任务

### 1. 解决项目启动问题
- ✅ 修复nginx重复启动问题（创建安全启动脚本）
- ✅ 解决MySQL连接问题（添加allowPublicKeyRetrieval参数）
- ✅ 项目成功运行，前端显示店铺列表

### 2. 秒杀代码学习
- ✅ 学习检查阶段（第38-55行）
- ✅ 学习一人一单逻辑（第58-70行）
- ✅ 学习乐观锁防超卖（第73-81行）
- ⏳ 创建订单部分（留到下次）

---

## 🎯 核心知识点

### 方法调用链（链式调用）

```java
voucher.getBeginTime().isAfter(LocalDateTime.now())
```

**执行过程：**
1. `voucher.getBeginTime()` → 返回 LocalDateTime 对象
2. 在返回的对象上调用 `.isAfter(参数)`
3. `LocalDateTime.now()` 作为参数
4. 返回 boolean 结果

**关键：** 方法返回对象，对象可以继续调用方法

---

### synchronized锁（防一人多单）

```java
synchronized (userId.toString().intern()) {
    // 查询是否已购买
    // 扣减库存、创建订单
}
```

**核心理解：**
- 锁对象：`userId.toString().intern()`
- `.intern()` 保证相同字符串指向同一个对象
- 同一用户的请求排队，不同用户不影响

**为什么需要：**
防止同一用户手抖点两次，创建两个订单

**执行流程：**
```
请求A：获得锁 → 查count=0 → 创建订单 → 释放锁
请求B：等待锁 → 获得锁 → 查count=1 → 返回"限购一张"
```

---

### 乐观锁（防超卖核心）

```java
seckillVoucherService.update()
    .setSql("stock = stock - 1")
    .eq("voucher_id", voucherId)
    .gt("stock", 0)  // ← 核心
    .update();
```

**生成的SQL：**
```sql
UPDATE tb_seckill_voucher
SET stock = stock - 1
WHERE voucher_id = ? AND stock > 0
```

**核心理解：**
- `.gt("stock", 0)` 是UPDATE的WHERE条件（不是查询条件）
- 数据库行锁机制：检查WHERE + 执行SET是原子操作
- 只有一个线程的UPDATE会成功（影响1行）
- 其他线程的UPDATE会失败（影响0行，因为stock=0）

**为什么能防超卖：**
```
库存=1，线程A和B同时到达

线程A：UPDATE WHERE stock > 0
  → 加锁 → 检查满足 → stock-1 → 释放锁
  → 影响1行（成功）

线程B：UPDATE WHERE stock > 0
  → 加锁 → 检查不满足(stock=0) → 不执行SET
  → 影响0行（失败）
```

---

### 快速检查 vs 乐观锁

| 对比 | 快速检查（第52行） | 乐观锁（第76行） |
|------|-----------------|----------------|
| 代码 | `if (stock < 1)` | `.gt("stock", 0)` |
| 作用 | 性能优化 | 真正防超卖 |
| 原理 | 并发读取 | 数据库行锁+原子性 |
| 能否防超卖 | ❌ 不能 | ✅ 能 |

---

### 两把锁的区别

| 锁类型 | 位置 | 作用 | 锁的范围 | 实现层面 |
|--------|------|------|----------|----------|
| synchronized | 第61行 | 防一人多单 | 同一用户的请求 | Java代码 |
| 乐观锁 | 第76行 | 防超卖 | 所有用户竞争同一券 | 数据库 |

---

## 📚 今天学会的技术

### Java语法
- ✅ 方法调用链（链式调用）
- ✅ synchronized 关键字
- ✅ String.intern() 字符串常量池

### Java 8 API
- ✅ LocalDateTime 日期时间类
- ✅ isAfter() / isBefore() 时间比较

### MyBatis-Plus
- ✅ getById(id) 根据主键查询
- ✅ query().eq().count() 条件查询
- ✅ update().setSql().gt().update() 链式UPDATE

### 数据库
- ✅ 数据库行锁机制
- ✅ UPDATE的WHERE条件原子性
- ✅ 乐观锁 vs 悲观锁

### Spring框架
- ✅ @Resource 依赖注入
- ✅ Service层的作用
- ✅ ThreadLocal 线程本地存储（UserHolder）

---

## 💡 重要认知

### 1. 方法调用链的本质
链式调用就像流水线：
```
原材料 → 工序1 → 半成品 → 工序2 → 成品
voucher → getBeginTime() → LocalDateTime → isAfter() → boolean
```

### 2. synchronized锁的范围
- 锁对象决定了锁的范围
- 同一对象的请求会排队
- 不同对象的请求不影响

### 3. 乐观锁的关键
- `.gt("stock", 0)` 不是查询，是UPDATE的WHERE条件
- 数据库保证了WHERE检查 + SET操作的原子性
- 这是防超卖的核心机制

### 4. 快速检查的作用
- 只是性能优化，不能防超卖
- 并发读取无法保证原子性
- 真正防超卖靠乐观锁

---

## 🔧 今天解决的问题

### 问题1：nginx重复启动导致端口冲突
**症状：** 前端页面显示"店铺加载失败"
**原因：** 每次启动创建新nginx进程，累积12个进程
**解决：** 创建 start-nginx-safe.bat 脚本，检查是否已运行

### 问题2：MySQL连接报错
**症状：** Public Key Retrieval is not allowed
**原因：** MySQL 8.0认证方式与老驱动不兼容
**解决：** 添加 `allowPublicKeyRetrieval=true` 参数

---

## 📂 创建的文档

1. **docs/代码学习模板.md** - 逐行讲解的标准模板
2. **README-启动说明.md** - 完整的项目启动说明
3. **start-nginx-safe.bat** - 安全启动nginx脚本
4. **stop-nginx.bat** - 优雅停止nginx脚本
5. **start-project.bat** - 一键启动项目脚本

---

## ⏭️ 下次学习计划

### 1. 完成秒杀代码学习
- 学习创建订单部分（第84-98行）
- 理解RedisIdWorker（全局唯一ID）
- 整体回顾秒杀流程

### 2. 实践调试
- 在IDEA中打断点
- 单步执行秒杀代码
- 查看变量值
- 验证理解

### 3. 可选扩展
- 用JMeter模拟高并发
- 测试乐观锁是否真的防超卖
- 测试synchronized是否真的防一人多单

---

## 🎯 学习收获

### 知识层面
- 深入理解了链式调用的执行过程
- 掌握了synchronized锁的使用场景
- 理解了乐观锁防超卖的底层原理
- 理解了两把锁的配合使用

### 能力层面
- 学会了逐行分析复杂代码
- 能够拆解方法调用链
- 能够用场景模拟理解并发问题
- 能够区分不同层面的解决方案（Java代码 vs 数据库）

### 方法层面
- 确立了适合自己的学习方法（详细但不啰嗦）
- 创建了代码学习模板
- 养成了记录学习过程的习惯

---

## 💪 明天继续加油！

今天解决了项目启动问题，学习了秒杀代码的核心逻辑。

明天继续完成剩余部分，并用调试验证理解。

**记住：**
- 看懂 ≠ 学会
- 必须通过调试实践才能真正掌握
- 理解底层原理比记住代码更重要

---

**总结完成时间：** 2026-02-16 晚上
**下次学习：** 继续秒杀代码 + 实践调试
